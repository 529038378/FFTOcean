// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel PostKernel

# include "MathUtil.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> HeightPingTex;
RWTexture2D<float4> HeightPongTex;
RWTexture2D<float4> DisplacePingTex;
RWTexture2D<float4> DisplacePongTex;
RWTexture2D<float4> NormalPingTex;
RWTexture2D<float4> NormalPongTex;
RWTexture2D<float4> JacobPingTex;
RWTexture2D<float4> JacobPongTex;
RWTexture2D<float4> LutTex;
int Ping;
//RWTexture2D<float4> DebugTex;

uint GroupSize;
uint Stage;
float Length;
uint TotalStageCount;
uint Size;
int ComputeLine;

float CalSymbol(uint2 id)
{
    int exp = (int)id.x + (int)id.y - (int)Size / 2;
    return (exp % 2 != 0) ? -1 : 1;
    //pow 不支持底为复数
    //return pow(-1, id.x * 1.0f - Size * 0.5f + id.y * 1.0f);
}

float2 CalDisplaceKModule(float2 k, float2 input)
{
    float k_mag = CalMagnitude(k);
    if (k_mag < 0.0001)
    {
        return float2(0, 0);
    }
    float2 res = k / k_mag;
    res = MulComplex(res, input);
    res = float2(res.y, -res.x);
    return res;
}

float4 CalNormalModule(float2 k, float4 input)
{
    //取实部作为对应的值
    float4 res;
    res.x = -1 * (k.x * input.z);
    res.y = k.x * input.x;
    res.z = -1 * (k.y * input.z);
    res.w = k.y * input.x;
    return res;
}

float4 CalSum(float2 self, float2 pat, float2 weight, float reverse)
{
    float2 mul = -1 == reverse ? self : pat;
    float2 non_mul = -1 == reverse ? pat : self;
    float2 weight_pat_mul_com = MulComplex(weight, mul);
    float real = reverse * weight_pat_mul_com.x + non_mul.x;
    float ima = reverse * weight_pat_mul_com.y + non_mul.y;
    return float4(real, 0, ima, 1);
}

float3 NormalizeVector(float3 normal)
{
    float length = CalMagnitudeVec3(normal);
    return normal / length;
}

[numthreads(8, 8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 cor = id.xy;
    cor.y = Stage;
    uint2 pat_cor;
    cor.x = 1 == ComputeLine ? id.x : id.y;
    float4 weight = LutTex[cor];
    int reverse = (cor.x % GroupSize) >= (GroupSize / 2) ? -1 : 1;
    uint2 real_index = id.xy;

    if(1 == ComputeLine)
    {
        real_index.x = (0 == Stage) ? CalBitReverse(id.x, TotalStageCount) : id.x;
        pat_cor.x = (0 == Stage) ? CalBitReverse(id.x + reverse, TotalStageCount) : (id.x + reverse * (int)GroupSize/2);
        pat_cor.y = id.y;
    }
    else
    {
        real_index.y = (0 == Stage) ? CalBitReverse(id.y, TotalStageCount) : id.y;
        pat_cor.x = id.x;
        pat_cor.y = (0 == Stage) ? CalBitReverse(id.y + reverse, TotalStageCount) : (id.y + reverse * (int)GroupSize/2);
    }

    float4 self_input = (1 == Ping) ? HeightPingTex[real_index] : HeightPongTex[real_index];
    float4 pat_input = (1 == Ping) ? HeightPingTex[pat_cor] : HeightPongTex[pat_cor];
    float4 self_displace_input = (1 == Ping) ? DisplacePingTex[real_index] : DisplacePongTex[real_index];
    float4 pat_displace_input = (1 == Ping) ? DisplacePingTex[pat_cor] : DisplacePongTex[pat_cor];
    float4 self_normal_input = (1 == Ping) ? NormalPingTex[real_index] : NormalPongTex[real_index];
    float4 pat_normal_input = (1 == Ping) ? NormalPingTex[pat_cor] : NormalPongTex[pat_cor];
    
    //符号校正
    if(1 == ComputeLine && 0 == Stage)
    {
        float neg = cor.x % 2 == 0 ? 1 : -1;
        self_input *= neg;
        self_displace_input *= neg;
        self_normal_input *= neg;

        neg = pat_cor.x % 2 == 0 ? 1 : - 1;
        pat_input *= neg;
        pat_displace_input *= neg;
        pat_normal_input *= neg;
    }
    else if(0 == ComputeLine && 0 == Stage)
    {
        float neg = CalSymbol(cor.xy);
        self_input *= neg;
        self_displace_input *= neg;
        self_normal_input *= neg;

        neg = CalSymbol(pat_cor.xy);
        pat_input *= neg;
        pat_displace_input *= neg;
        pat_normal_input *= neg;
    }

    //高度图计算
    float2 weight_com = float2(weight.x, weight.z);
    float2 pat_com = float2(pat_input.x, pat_input.z);
    float2 self_com = float2(self_input.x, self_input.z);
    if(1 == Ping)
    {
        HeightPongTex[id.xy] = CalSum(self_com, pat_com, weight_com, reverse );
    }
    else
    {
        HeightPingTex[id.xy] = CalSum(self_com, pat_com, weight_com, reverse );
    }
   
    //displace计算
    float2 k_cor = float2(2.0f * PI * ((int)id.x - (int)Size/2)/Length, 2.0f * PI * ((int)id.y - (int)Size/2)/Length);
    float2 self_displace_input_com = float2(self_displace_input.x, self_displace_input.z);
    float2 pat_displace_input_com = float2(pat_displace_input.x, pat_displace_input.z);
    float2 displace_self_com = 0 == Stage ? CalDisplaceKModule(k_cor, self_displace_input_com) : self_displace_input_com;
    float2 displace_pat_com = 0 == Stage ? CalDisplaceKModule(k_cor, pat_displace_input_com) : pat_displace_input_com;
    if(1 == Ping)
    {
        DisplacePongTex[id.xy] = CalSum(displace_self_com, displace_pat_com, weight_com, reverse);    
    }
    else
    {
        DisplacePingTex[id.xy] = CalSum(displace_self_com, displace_pat_com, weight_com, reverse);    
    }

    //normal计算,这里的complex中 xy表示x方向的complex，zw表示z方向的complex
    float4 normal_self_com = 0 == Stage ? CalNormalModule(k_cor, self_normal_input) : self_normal_input;
    float4 normal_pat_com = 0 == Stage ? CalNormalModule(k_cor, pat_normal_input) : pat_normal_input;  
    float4 normal_x_complex = CalSum(normal_self_com.xy, normal_pat_com.xy, weight_com, reverse);
    float4 normal_z_complex = CalSum(normal_self_com.zw, normal_pat_com.zw, weight_com, reverse);
    if(1 == Ping)
    {
        NormalPongTex[id.xy] = float4(normal_x_complex.x, normal_x_complex.z, normal_z_complex.x, normal_z_complex.z);
    }
    else
    {
        NormalPingTex[id.xy] = float4(normal_x_complex.x, normal_x_complex.z, normal_z_complex.x, normal_z_complex.z);
    }

    //jacob尖浪判断,x y z w分别表示Dxx Dzz Dzx Dxz

    //最后的符号校正
    if(0 == ComputeLine && (TotalStageCount - 1) == Stage)
    {
        float neg = (((int)id.y - (int)Size / 2 )% 2 == 0) ? 1 : -1;
        HeightPingTex[id.xy] *= neg;
        DisplacePongTex[id.xy] *= neg;
        NormalPongTex[id.xy] *= neg;
    }
}

[numthreads(8, 8,1)]
void PostKernel (uint3 id : SV_DispatchThreadID)
{
    float3 normal = float3(0, 1, 0) - float3(NormalPingTex[id.xy].x, 0, NormalPingTex[id.xy].z);
    normal = NormalizeVector(normal);
    NormalPongTex[id.xy] = float4(normal.x, normal.y, normal.z, 1);
}
