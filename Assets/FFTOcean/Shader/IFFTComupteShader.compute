// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

# include "MathUtil.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;
RWTexture2D<float4> LutTex;
int Stage;
uint GroupSize;
uint Size;
int ComputeLine;

float CalSymbol(uint2 id)
{
    int exp = id.x * 1.0f + id.y * 1.0f - Size / 2;
    return (exp % 2 != 0) ? -1 : 1;
    //pow 不支持底为-1
    //return pow(-1, id.x * 1.0f - Size * 0.5f + id.y * 1.0f);
}

[numthreads(8, 8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 cor = id.xy;
    cor.x = ComputeLine == 1 ? id.x : id.y;
    cor.y = Stage;
    float4 weight = LutTex[cor];
    int reverse = (cor.x % GroupSize) >= (GroupSize / 2) ? -1 : 1;
    uint2 pat_cor;
    pat_cor.x = ComputeLine == 1 ? CalBitReverse(id.x) : id.x;
    pat_cor.y = ComputeLine == 1 ? id.y: CalBitReverse(id.y);
    float4 self_input = InputTex[id.xy];
    float4 pat_input = InputTex[pat_cor];
    //符号校正
    if(0 == ComputeLine && 0 == Stage)
    {
        self_input *= CalSymbol(id.xy);
        pat_input *= CalSymbol(pat_cor);
    }
    float real = reverse * weight.x * pat_input.x + self_input.x;
    float ima = reverse * weight.z * pat_input.z + self_input.z;
    float mul_real = cos((2 * PI * id.x * id.x) / Size);
    float mul_ima = sin((2 * PI * id.x * id.x) / Size);
    OutputTex[id.xy] = float4(real * mul_real - ima * mul_ima,0, ima * mul_real + real * mul_ima, 1);
    
}
