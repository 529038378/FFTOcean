// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel PostKernel
#pragma kernel JacobKernel

# include "MathUtil.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> HeightPingTex;
RWTexture2D<float4> HeightPongTex;
RWTexture2D<float4> DisplacePingTex;
RWTexture2D<float4> DisplacePongTex;
RWTexture2D<float4> NormalPingTex;
RWTexture2D<float4> NormalPongTex;
RWTexture2D<float4> JacobPingDxxDzzTex;
RWTexture2D<float4> JacobPongDxxDzzTex;
RWTexture2D<float4> JacobPingDxzDzxTex;
RWTexture2D<float4> JacobPongDxzDzxTex;
RWTexture2D<float4> LutTex;
RWTexture2D<float4> JacobResTex;
int Ping;
float JacobScale;
RWTexture2D<float4> DebugTex;

uint GroupSize;
uint Stage;
float Length;
uint TotalStageCount;
uint Size;
int ComputeLine;

float CalSymbol(uint2 id)
{ 
    int exp = (int)id.x + (int)id.y - (int)Size / 2;
    return (exp % 2 != 0) ? -1 : 1;
    //pow 不支持底为复数
    //return pow(-1, id.x * 1.0f - Size * 0.5f + id.y * 1.0f);
}

float4 CalDisplaceKModule(float2 k, float4 input)
{
    float k_mag = CalMagnitude(k);
    if (k_mag < 0.0001)
    {
        return float4(0, 0, 0, 0);
    }
    float2 module = k / k_mag;
    float4 res;
    res.x = module.x * input.z; 
    res.y = -1 * module.x * input.x;
    res.z = module.y * input.z;
    res.w = -1 * module.y * input.x;
    return res;
}

float4 CalNormalModule(float2 k, float4 input)
{
    //取实部作为对应的值
    float4 res;
    res.x = -1 * (k.x * input.z);
    res.y = k.x * input.x;
    res.z = -1 * (k.y * input.z);
    res.w = k.y * input.x;
    return res;
}

float4 CalSum(float2 self, float2 pat, float2 weight, float reverse)
{
    float2 mul = -1 == reverse ? self : pat;
    float2 non_mul = -1 == reverse ? pat : self;
    float2 weight_pat_mul_com = MulComplex(weight, mul);
    float real = reverse * weight_pat_mul_com.x + non_mul.x;
    float ima = reverse * weight_pat_mul_com.y + non_mul.y;
    return float4(real, 0, ima, 1);
}

float4 Cal2Sum(float4 selfs, float4 pats, float2 weight, float reverse)
{
    float4 x_sum = CalSum(float2(selfs.x, selfs.y), float2(pats.x, pats.y), weight, reverse);
    float4 z_sum = CalSum(float2(selfs.z, selfs.w), float2(pats.z, pats.w), weight, reverse);
    return float4(x_sum.x, x_sum.z, z_sum.x, z_sum.z);
}

float3 NormalizeVector(float3 normal)
{
    float length = CalMagnitudeVec3(normal);
    return normal / length;
}

float4 CalJacobDxxDzz(float2 cor, float2 input)
{
    float cor_mag = CalMagnitude(cor);
    float2 Dxx = cor.x * cor.x / cor_mag * input; 
    float2 Dzz = cor.y * cor.y / cor_mag * input;
    return float4(Dxx.x, Dxx.y, Dzz.x, Dzz.y);      
}

float4 CalJacobDxzDzx(float2 cor, float2 input)
{
    float cor_mag = CalMagnitude(cor);
    float2 D = cor.x * cor.y / cor_mag * input;
    return float4(D.x, D.y, D.x, D.y);
}

[numthreads(8, 8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 cor = id.xy;
    cor.y = Stage;
    cor.x = 1 == ComputeLine ? id.x : id.y;
    uint2 pat_cor;
    float4 weight = LutTex[cor];
    int reverse = (cor.x % GroupSize) >= (GroupSize / 2) ? -1 : 1;
    uint2 real_index = id.xy;
    if(1 == ComputeLine)
    {
        real_index.x = (0 == Stage) ? CalBitReverse(id.x, TotalStageCount) : id.x;
        pat_cor.x = (0 == Stage) ? CalBitReverse(id.x + reverse, TotalStageCount) : (id.x + reverse * (int)GroupSize/2);
        pat_cor.y = id.y;
    }
    else
    {
        real_index.y = (0 == Stage) ? CalBitReverse(id.y, TotalStageCount) : id.y;
        pat_cor.x = id.x;
        pat_cor.y = (0 == Stage) ? CalBitReverse(id.y + reverse, TotalStageCount) : (id.y + reverse * (int)GroupSize/2);
    }
    float4 self_input = (1 == Ping) ? HeightPingTex[real_index] : HeightPongTex[real_index];
    float4 pat_input = (1 == Ping) ? HeightPingTex[pat_cor] : HeightPongTex[pat_cor];
    float4 self_displace_input = (1 == Ping) ? DisplacePingTex[real_index] : DisplacePongTex[real_index];
    float4 pat_displace_input = (1 == Ping) ? DisplacePingTex[pat_cor] : DisplacePongTex[pat_cor];
    float4 self_normal_input = (1 == Ping) ? NormalPingTex[real_index] : NormalPongTex[real_index];
    float4 pat_normal_input = (1 == Ping) ? NormalPingTex[pat_cor] : NormalPongTex[pat_cor];
   
    //符号校正
    if(1 == ComputeLine && 0 == Stage)
    {
        float neg = real_index.x % 2 == 0 ? 1 : -1;
        self_input *= neg;
        self_displace_input *= neg;
        self_normal_input *= neg;

        neg = pat_cor.x % 2 == 0 ? 1 : - 1;
        pat_input *= neg;
        pat_displace_input *= neg;
        pat_normal_input *= neg;
    }
    else if(0 == ComputeLine && 0 == Stage)
    {
        float neg = CalSymbol(real_index);
        self_input *= neg;
        self_displace_input *= neg;
        self_normal_input *= neg;

        neg = CalSymbol(pat_cor.xy);
        pat_input *= neg;
        pat_displace_input *= neg;
        pat_normal_input *= neg;
    }
    //高度图计算
    float2 weight_com = float2(weight.x, weight.z);
    float2 pat_com = float2(pat_input.x, pat_input.z);
    float2 self_com = float2(self_input.x, self_input.z);
    if(1 == Ping)
    {
        HeightPongTex[id.xy] = CalSum(self_com, pat_com, weight_com, reverse );
    }
    else
    {
        HeightPingTex[id.xy] = CalSum(self_com, pat_com, weight_com, reverse );
    }
  
    //displace计算
    float2 k_cor = float2(2.0f * PI * ((int)real_index.x - (int)Size/2)/Length, 2.0f * PI * ((int)real_index.y - (int)Size/2)/Length);
    float2 pat_k_cor = float2(2.0f * PI * ((int)pat_cor.x - (int)Size/2)/Length, 2.0f * PI *((int)pat_cor.x - (int)Size/2)/Length);
    float4 displace_self_com = (0 == Stage && 1 == ComputeLine ) ? CalDisplaceKModule(k_cor, self_displace_input) : self_displace_input;
    float4 displace_pat_com = (0 == Stage && 1 == ComputeLine) ? CalDisplaceKModule(pat_k_cor, pat_displace_input) : pat_displace_input;
    float4 displace_x_complex = CalSum(displace_self_com.xy, displace_pat_com.xy, weight_com, reverse);
    float4 displace_z_complex = CalSum(displace_self_com.zw, displace_pat_com.zw, weight_com, reverse);
    if(1 == Ping)
    {
        DisplacePongTex[id.xy] = float4(displace_x_complex.x, displace_x_complex.z, displace_z_complex.x, displace_z_complex.z);    
        //DebugTex[id.xy] = float4(DisplacePongTex[id.xy].x, 0, DisplacePongTex[id.xy].y, 1);
    }
    else
    {
        DisplacePingTex[id.xy] = float4(displace_x_complex.x, displace_x_complex.z, displace_z_complex.x, displace_z_complex.z);   
        //DebugTex[id.xy] = float4(DisplacePingTex[id.xy].x, 0, DisplacePingTex[id.xy].y, 1);
    }

    //normal计算,这里的complex中 xy表示x方向的complex，zw表示z方向的complex
    float4 normal_self_com = (0 == Stage && 1 == ComputeLine )? CalNormalModule(k_cor, self_normal_input) : self_normal_input;
    float4 normal_pat_com = (0 == Stage && 1 == ComputeLine )? CalNormalModule(pat_k_cor, pat_normal_input) : pat_normal_input;  
    float4 normal_x_complex = CalSum(normal_self_com.xy, normal_pat_com.xy, weight_com, reverse);
    float4 normal_z_complex = CalSum(normal_self_com.zw, normal_pat_com.zw, weight_com, reverse);
    if(1 == Ping)
    {
        NormalPongTex[id.xy] = float4(normal_x_complex.x, normal_x_complex.z, normal_z_complex.x, normal_z_complex.z);
        //DebugTex[id.xy] = float4(NormalPongTex[id.xy].x, 0, NormalPongTex[id.xy].y, 1);
    }
    else
    {
        NormalPingTex[id.xy] = float4(normal_x_complex.x, normal_x_complex.z, normal_z_complex.x, normal_z_complex.z);
        //DebugTex[id.xy] = float4(NormalPingTex[id.xy].x, 0, NormalPingTex[id.xy].y, 1);
    }
    //最后的符号校正
    if(0 == ComputeLine && (TotalStageCount - 1) == Stage)
    {
        float neg = (((int)real_index.y - (int)Size / 2 )% 2 == 0) ? 1 : -1;
        if(1 == Ping)
        {
            HeightPongTex[id.xy] *= neg;
            DisplacePongTex[id.xy] *= neg;
            NormalPongTex[id.xy] *= neg;
        }
        else
        {
            HeightPingTex[id.xy] *= neg;
            DisplacePingTex[id.xy] *= neg;
            NormalPingTex[id.xy] *= neg;
        }
        HeightPingTex[id.xy] = float4(HeightPingTex[id.xy].x, 0, HeightPingTex[id.xy].z, 1);
        HeightPongTex[id.xy] = float4(HeightPongTex[id.xy].x, 0, HeightPongTex[id.xy].z, 1);
    }
}
[numthreads(8,8,1)]
void PostKernel (uint3 id : SV_DispatchThreadID)
{
    //normal post
    float3 grad = 1 == Ping ? float3(NormalPingTex[id.xy].x, 0, NormalPingTex[id.xy].z) : float3(NormalPongTex[id.xy].x, 0, NormalPongTex[id.xy].z);
    float3 normal = float3(0, 1, 0) - grad;
    normal = NormalizeVector(normal);
    if(1 == Ping)
    {
        NormalPongTex[id.xy] = float4(normal.x, normal.y, normal.z, 1);
    }
    else
    {
        NormalPongTex[id.xy] = float4(normal.x, normal.y, normal.z, 1);
    }
    //jacob post
    float4 JacobDxxDzzInput = 1== Ping ? JacobPingDxxDzzTex[id.xy] : JacobPongDxxDzzTex[id.xy];
    float4 JacobDxzDzxInput = 1== Ping ? JacobPingDxzDzxTex[id.xy] : JacobPongDxzDzxTex[id.xy];
    float2 Jxx = 1 + JacobScale * JacobDxxDzzInput.xy;
    float2 Jzz = 1 + JacobScale * JacobDxxDzzInput.zw;
    float2 Jxz = JacobScale * JacobDxzDzxInput.xy;
    float2 Jzx = Jxz;
    float jacob = Jxx * Jzz - Jxz * Jzx;
    JacobResTex[id.xy] = 0 >= jacob ? float4(1, 1, 1, 1) : float4(0, 0, 0, 0);
}
[numthreads(8, 8, 1)]
void JacobKernel(uint3 id : SV_DispatchThreadID)
{
    uint2 cor = id.xy;
    cor.y = Stage;
    cor.x = 1 == ComputeLine ? id.x : id.y;
    uint2 pat_cor;
    float4 weight = LutTex[cor];
    int reverse = (cor.x % GroupSize) >= (GroupSize / 2) ? -1 : 1;
    uint2 real_index = id.xy;
    if(1 == ComputeLine)
    {
        real_index.x = (0 == Stage) ? CalBitReverse(id.x, TotalStageCount) : id.x;
        pat_cor.x = (0 == Stage) ? CalBitReverse(id.x + reverse, TotalStageCount) : (id.x + reverse * (int)GroupSize/2);
        pat_cor.y = id.y;
    }
    else
    {
        real_index.y = (0 == Stage) ? CalBitReverse(id.y, TotalStageCount) : id.y;
        pat_cor.x = id.x;
        pat_cor.y = (0 == Stage) ? CalBitReverse(id.y + reverse, TotalStageCount) : (id.y + reverse * (int)GroupSize/2);
    }
    float2 k_cor = float2(2.0f * PI * ((int)real_index.x - (int)Size/2)/Length, 2.0f * PI * ((int)real_index.y - (int)Size/2)/Length);
    float2 pat_k_cor = float2(2.0f * PI * ((int)pat_cor.x - (int)Size/2)/Length, 2.0f * PI *((int)pat_cor.x - (int)Size/2)/Length);
    float4 self_Jacob_DxxDzz_input = (1 == Ping) ? JacobPingDxxDzzTex[real_index] : JacobPongDxxDzzTex[real_index];
    float4 pat_Jacbo_DxxDzz_input = (1 == Ping) ? JacobPingDxxDzzTex[pat_cor] : JacobPongDxxDzzTex[pat_cor];
    float4 self_Jacob_DxzDzx_input = (1 == Ping) ? JacobPingDxzDzxTex[real_index] : JacobPongDxzDzxTex[real_index];
    float4 pat_Jacob_DxzDzx_input = (1 == Ping) ? JacobPingDxzDzxTex[pat_cor] : JacobPongDxzDzxTex[pat_cor];
     //符号校正
    if(1 == ComputeLine && 0 == Stage)
    {
        float neg = cor.x % 2 == 0 ? 1 : -1;
        self_Jacob_DxxDzz_input *= neg;
        self_Jacob_DxzDzx_input *= neg;

        neg = pat_cor.x % 2 == 0 ? 1 : - 1;
        pat_Jacbo_DxxDzz_input *= neg;
        pat_Jacob_DxzDzx_input *= neg;
    }
    else if(0 == ComputeLine && 0 == Stage)
    {
        float neg = CalSymbol(cor.xy);
        self_Jacob_DxxDzz_input *= neg; 
        self_Jacob_DxzDzx_input *= neg;

        neg = CalSymbol(pat_cor.xy);
        pat_Jacbo_DxxDzz_input *= neg;
        pat_Jacob_DxzDzx_input *= neg;
    }
    //jacob尖浪判断,分别表示Dxx Dzz存在一个JacobDxxDzzPing/PongBuff里， Dxz Dzx存在JacobDxzDzxPing/PongBuff里
    float4 Jacob_DxxDzz_self_com = (0 == Stage && 1 == ComputeLine)? CalJacobDxxDzz(k_cor, self_Jacob_DxxDzz_input) : self_Jacob_DxxDzz_input;
    float4 Jacob_DxxDzz_pat_com =  (0 == Stage && 1 == ComputeLine)? CalJacobDxxDzz(pat_k_cor, pat_Jacbo_DxxDzz_input) : pat_Jacbo_DxxDzz_input;
    float4 Jacob_DxzDzx_self_com = (0 == Stage && 1 == ComputeLine)? CalJacobDxzDzx(k_cor, self_Jacob_DxzDzx_input) : self_Jacob_DxzDzx_input;
    float4 Jacob_DxzDzx_pat_com = (0 == Stage && 1 == ComputeLine)? CalJacobDxzDzx(pat_k_cor, pat_Jacob_DxzDzx_input) : pat_Jacob_DxzDzx_input;
    float4 Jacob_DxxDzz_com = Cal2Sum(Jacob_DxxDzz_self_com, Jacob_DxxDzz_pat_com, weight, reverse);
    float4 Jacob_DxzDzx_com = Cal2Sum(Jacob_DxzDzx_self_com, Jacob_DxzDzx_pat_com, weight, reverse);
    if(1 == Ping)
    {
        JacobPongDxxDzzTex[id.xy] = Jacob_DxxDzz_com;
        JacobPongDxzDzxTex[id.xy] = Jacob_DxzDzx_com;
    }
    else
    {
        JacobPingDxxDzzTex[id.xy] = Jacob_DxxDzz_com;
        JacobPingDxzDzxTex[id.xy] = Jacob_DxzDzx_com;
    }
    if(0 == ComputeLine && (TotalStageCount - 1) == Stage)
    {
        float neg = (((int)id.y - (int)Size / 2 )% 2 == 0) ? 1 : -1;
        if(1 == Ping)
        {
            JacobPongDxxDzzTex[id.xy] *= neg;
            JacobPongDxzDzxTex[id.xy] *= neg;
        }
        else
        {
            JacobPingDxxDzzTex[id.xy] *= neg;
            JacobPingDxzDzxTex[id.xy] *= neg;
        }
    }
}